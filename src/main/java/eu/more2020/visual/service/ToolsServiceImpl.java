package eu.more2020.visual.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import eu.more2020.visual.config.ApplicationProperties;
import eu.more2020.visual.domain.*;

import eu.more2020.visual.domain.Detection.ChangepointDetection;
import eu.more2020.visual.domain.Detection.DeviationDetection;
import eu.more2020.visual.domain.Detection.PatternDetection;
import eu.more2020.visual.domain.Detection.RangeDetection;
import eu.more2020.visual.domain.GrpcAutoGenerated.RouteGuideGrpc;
import eu.more2020.visual.domain.GrpcAutoGenerated.tools.*;
import eu.more2020.visual.middleware.domain.ImmutableDataPoint;
import eu.more2020.visual.middleware.domain.ImmutableMultivariateDataPoint;
import eu.more2020.visual.middleware.domain.MultiVariateDataPoint;
import eu.more2020.visual.middleware.domain.TimeRange;
import eu.more2020.visual.middleware.util.DateTimeUtil;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.netty.NettyChannelBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.io.*;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.temporal.ChronoField;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Service
public class ToolsServiceImpl extends RouteGuideGrpc.RouteGuideImplBase implements ToolsService {

    private final ApplicationProperties applicationProperties;

    private final DateTimeFormatter formatter;

    private final Logger log = LoggerFactory.getLogger(ToolsServiceImpl.class);

    public ToolsServiceImpl(ApplicationProperties applicationProperties) {
        this.applicationProperties = applicationProperties;
        this.formatter =
            new DateTimeFormatterBuilder().appendPattern(applicationProperties.getTimeFormat())
                .parseDefaulting(ChronoField.HOUR_OF_DAY, 0)
                .parseDefaulting(ChronoField.MINUTE_OF_HOUR, 0)
                .parseDefaulting(ChronoField.SECOND_OF_MINUTE, 0)
                .toFormatter();
    }

    public List<String> toDateArray(Iterator<JsonNode> iterator) {

        List<String> dates = new ArrayList<>();
        while (iterator.hasNext()) {
            JsonNode dateNode = iterator.next();
            dates.add(dateNode.asText());
        }
        return dates;
    }

    @Override
    public List<Changepoint> getManualChangepoints(String id) {
        List<Changepoint> gtChangepoints = new ArrayList<>();
        try {
            WashesRequest request = WashesRequest.newBuilder()
                .setDatasetId(id)
                .build();

            // Create a channel to connect to the target gRPC server
            ManagedChannel channel = ManagedChannelBuilder.forAddress(applicationProperties.getToolHost(), applicationProperties.getToolPort())
                .usePlaintext()
                .idleTimeout(2, TimeUnit.SECONDS)
                .build();

            // Create a stub using the generated code and the channel
            DataServiceGrpc.DataServiceBlockingStub stub = DataServiceGrpc.newBlockingStub(channel);

            // Invoke the remote method on the target server
            WashesResponse response = stub.checkWashes(request);

            // Convert the response to JSON string
            String json = response.getWashes();
            // Create an ObjectMapper
            ObjectMapper objectMapper = new ObjectMapper();

            // Deserialize the JSON string into a Response object
            JsonNode responseObject = objectMapper.readTree(json);
            log.info("READ JSON: {}", responseObject);
            JsonNode starts = responseObject.get("Starting_date");
            JsonNode ends = responseObject.get("Ending_date");
            Integer noOfIntervals = starts.size();
            for (Integer i = 0; i < noOfIntervals; i++) {
                String ii = i.toString();
                gtChangepoints.add(new Changepoint(i, new TimeRange(DateTimeUtil.parseDateTimeString(starts.get(ii).asText(), formatter, ZoneId.of("UTC")),
                    DateTimeUtil.parseDateTimeString(ends.get(ii).asText(), formatter, ZoneId.of("UTC"))), 0));
            }
            // Shutdown the channel
            channel.shutdown();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return gtChangepoints;
    }

    @Override
    public List<MultiVariateDataPoint> forecasting(String id) {
        String jsonName = applicationProperties.getWorkspacePath() + "/" + id + "_predict.json";
        File json = new File(jsonName);
        List<MultiVariateDataPoint> forecastData = new ArrayList<>();
        if (json.exists()) {
            // read json
            try {
                ObjectMapper objectMapper = new ObjectMapper();
                BufferedReader in = new BufferedReader(
                    new FileReader(json));
                String inputLine;
                StringBuffer content = new StringBuffer();
                while ((inputLine = in.readLine()) != null) {
                    content.append(inputLine);
                }
                JsonNode responseObject = objectMapper.readTree(content.toString());
                Iterator<Map.Entry<String, JsonNode>> iter = responseObject.fields();
                while (iter.hasNext()) {
                    Map.Entry<String, JsonNode> datum = iter.next();
                    double[] vals = new double[1];
                    vals[0] = datum.getValue().asDouble();
                    MultiVariateDataPoint dataPoint = new ImmutableMultivariateDataPoint(Instant.ofEpochMilli(Long.parseLong(datum.getKey())).toEpochMilli(), vals);
                    forecastData.add(dataPoint);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
        return forecastData;
    }

    @Override
    public List<Changepoint> changepointDetection(ChangepointDetection changepointDetection) {
        List<Changepoint> detectedChangepoints = new ArrayList<>();
        try {
            CPDetectionRequest request = CPDetectionRequest.newBuilder()
                .setDatasetId(changepointDetection.getId())
                .setStartDate(changepointDetection.getRange().getFromDate())
                .setEndDate(changepointDetection.getRange().getToDate())
                .setThrsh(1)
                .setWa1(10)
                .setWa2(5)
                .setWa3(10)
                .build();

            // Create a channel to connect to the target gRPC server
            ManagedChannel channel = NettyChannelBuilder.forAddress(applicationProperties.getToolHost(), applicationProperties.getToolPort())
                .usePlaintext()
                .idleTimeout(5, TimeUnit.SECONDS)
                .build();

            // Create a stub using the generated code and the channel
            DataServiceGrpc.DataServiceBlockingStub stub = DataServiceGrpc.newBlockingStub(channel);

            // Invoke the remote method on the target server
            CPDetectionResponse response = stub.cPDetection(request);

            // Convert the response to JSON string
            String json = response.getResult();
            // Create an ObjectMapper
            ObjectMapper objectMapper = new ObjectMapper();

            JsonNode responseObject = objectMapper.readTree(json);
            log.info("READ JSON: {}", responseObject);
            JsonNode starts = responseObject.get("Starting date");
            JsonNode ends = responseObject.get("Ending date");
            Integer noOfIntervals = starts.size();
            for (Integer i = 0; i < noOfIntervals; i++) {
                String ii = i.toString();
                detectedChangepoints.add(
                    new Changepoint(i, new TimeRange(DateTimeUtil.parseDateTimeString(starts.get(ii).asText(), formatter, ZoneId.of("UTC")),
                    DateTimeUtil.parseDateTimeString(ends.get(ii).asText(), formatter, ZoneId.of("UTC"))), 0));
            }
            log.info("{}", detectedChangepoints);
            channel.shutdown();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return detectedChangepoints;
    }

    @Override
    public List<MultiVariateDataPoint> soilingDetection(DeviationDetection deviationDetection) {
        if (deviationDetection.getType().equals("soilingRatio")) {
            return getSoilingIndex(deviationDetection);
        } else if (deviationDetection.getType().equals("powerLoss")) {
            return getPowerLoss(deviationDetection);
        } else return getSoilingIndex(deviationDetection);
    }

    private List<MultiVariateDataPoint> getSoilingIndex(DeviationDetection deviationDetection) {
        List<MultiVariateDataPoint> dataPoints = new ArrayList<>();
        try {
            List<String> cpStarts = new ArrayList<>();
            List<String> cpEnds = new ArrayList<>();
            if (deviationDetection.getChangepoints() != null) {
                cpStarts = deviationDetection.getChangepoints().stream().map(changepoint -> DateTimeUtil.formatTimeStamp(formatter, changepoint.getRange().getFrom())).collect(Collectors.toList());
                cpEnds = deviationDetection.getChangepoints().stream().map(changepoint -> DateTimeUtil.formatTimeStamp(formatter, changepoint.getRange().getTo())).collect(Collectors.toList());
            }
            CalculatePowerIndexRequest request = CalculatePowerIndexRequest.newBuilder()
                .setDatasetId(deviationDetection.getId())
                .setStartDate(deviationDetection.getRange().getFromDate())
                .setEndDate(deviationDetection.getRange().getToDate())
                .setWeeksTrain(deviationDetection.getWeeks())
                .addAllCpStarts(cpStarts)
                .addAllCpEnds(cpEnds)
                .build();


            // Create a channel to connect to the target gRPC server
            ManagedChannel channel = ManagedChannelBuilder.forAddress(applicationProperties.getToolHost(), applicationProperties.getToolPort())
                .usePlaintext()
                .idleTimeout(5, TimeUnit.SECONDS)
                .build();

            // Create a stub using the generated code and the channel
            DataServiceGrpc.DataServiceBlockingStub stub = DataServiceGrpc.newBlockingStub(channel);

            // Invoke the remote method on the target server
            CalculatePowerIndexResponse response = stub.calculatePowerIndex(request);

            // Convert the response to JSON string
            String json = response.getResult();
            // Create an ObjectMapper
            ObjectMapper objectMapper = new ObjectMapper();

            JsonNode responseObject = null;

            responseObject = objectMapper.readTree(json);
            log.info("READ JSON: {}", responseObject.get("power_index"));
            JsonNode powerIndex = responseObject.get("power_index");
            powerIndex.fields().forEachRemaining(entry -> {
                long time = Long.parseLong(entry.getKey());
                String value = entry.getValue().asText();
                MultiVariateDataPoint dataPoint = new ImmutableMultivariateDataPoint(time, new double[]{Double.parseDouble(value)});
                dataPoints.add(dataPoint);
            });
            channel.shutdown();
            // Create an ObjectMapper
        } catch (Exception e) {
            e.printStackTrace();
        }
        return dataPoints;
    }


    private List<MultiVariateDataPoint> getPowerLoss(DeviationDetection deviationDetection) {
        List<MultiVariateDataPoint> dataPoints = new ArrayList<>();
        try {
            List<String> cpStarts = new ArrayList<>();
            List<String> cpEnds = new ArrayList<>();
            if (deviationDetection.getChangepoints() != null) {
                cpStarts = deviationDetection.getChangepoints().stream().map(changepoint -> DateTimeUtil.formatTimeStamp(formatter, changepoint.getRange().getFrom())).collect(Collectors.toList());
                cpEnds = deviationDetection.getChangepoints().stream().map(changepoint -> DateTimeUtil.formatTimeStamp(formatter, changepoint.getRange().getTo())).collect(Collectors.toList());
            }
            CalculatePowerIndexRequest request = CalculatePowerIndexRequest.newBuilder()
                .setDatasetId(deviationDetection.getId())
                .setStartDate(deviationDetection.getRange().getFromDate())
                .setEndDate(deviationDetection.getRange().getToDate())
                .setWeeksTrain(deviationDetection.getWeeks())
                .addAllCpStarts(cpStarts)
                .addAllCpEnds(cpEnds)
                .build();


            // Create a channel to connect to the target gRPC server
            ManagedChannel channel = ManagedChannelBuilder.forAddress(applicationProperties.getToolHost(), applicationProperties.getToolPort())
                .usePlaintext()
                .idleTimeout(5, TimeUnit.SECONDS)
                .build();

            // Create a stub using the generated code and the channel
            DataServiceGrpc.DataServiceBlockingStub stub = DataServiceGrpc.newBlockingStub(channel);

            // Invoke the remote method on the target server
            CalculatePowerIndexResponse response = stub.calculatePowerIndex(request);

            // Convert the response to JSON string
            String json = response.getResult();
            // Create an ObjectMapper
            ObjectMapper objectMapper = new ObjectMapper();

            JsonNode responseObject = null;

            responseObject = objectMapper.readTree(json);
            log.info("READ JSON: {}", responseObject.get("estimated_power_lost"));
            JsonNode powerIndex = responseObject.get("estimated_power_lost");
            powerIndex.fields().forEachRemaining(entry -> {
                long time = Long.parseLong(entry.getKey());
                String value = entry.getValue().asText();
                MultiVariateDataPoint dataPoint = new ImmutableMultivariateDataPoint(time, new double[]{Double.parseDouble(value)});
                dataPoints.add(dataPoint);
            });
            channel.shutdown();
            // Create an ObjectMapper
        } catch (Exception e) {
            e.printStackTrace();
        }
        return dataPoints;
    }

    @Override
    public List<MultiVariateDataPoint> yawMisalignmentDetection(RangeDetection rangeDetection) {
        List<MultiVariateDataPoint> dataPoints = new ArrayList<>();
        try {
            Map<String, Object> params = new LinkedHashMap<>();
            params.put("start_date", rangeDetection.getRange().getFromDate());
            params.put("end_date", rangeDetection.getRange().getToDate());

            EstimateYawMisalignmentRequest request = EstimateYawMisalignmentRequest.newBuilder()
                .setDatasetId(rangeDetection.getId())
                .setStartDate(rangeDetection.getRange().getFromDate())
                .setEndDate(rangeDetection.getRange().getToDate())
                .build();

            // Create a channel to connect to the target gRPC server
            ManagedChannel channel = ManagedChannelBuilder.forAddress(applicationProperties.getToolHost(),
                    applicationProperties.getToolPort())
                .usePlaintext()
                .idleTimeout(5, TimeUnit.SECONDS)
                .build();

            // Invoke the remote method on the target server
            DataServiceGrpc.DataServiceBlockingStub stub = DataServiceGrpc.newBlockingStub(channel);
            EstimateYawMisalignmentResponse response = stub.estimateYawMisalignment(request);

            // Convert the response to JSON string
            String json = response.getResult();
            // Create an ObjectMapper
            ObjectMapper objectMapper = new ObjectMapper();

            JsonNode responseObject = null;

            responseObject = objectMapper.readTree(json);
            log.info("READ JSON: {}", responseObject);
            JsonNode yaw = responseObject.get("y_pred");

            yaw.fields().forEachRemaining(entry -> {
                String time = entry.getKey();
                String value = entry.getValue().asText();
                MultiVariateDataPoint dataPoint = new ImmutableMultivariateDataPoint(DateTimeUtil.parseDateTimeString(time, "yyyy-MM-dd[ HH:mm:ss]"),
                    new double[]{Double.parseDouble(value)});
                dataPoints.add(dataPoint);
            });
            channel.shutdown();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return dataPoints;
    }

    @Override
    public List<Changepoint> patternDetection(PatternDetection patternDetection) {
        List<Changepoint> detectedPatterns = new ArrayList<>();
        try {
            log.info(String.valueOf(patternDetection));
            FrechetRequest request = FrechetRequest.newBuilder()
                .setStartDate(DateTimeUtil.formatTimeStamp(formatter, patternDetection.getRange().getFrom()))
                .setEndDate(DateTimeUtil.formatTimeStamp(formatter, patternDetection.getRange().getTo()))
                .build();


            // Create a channel to connect to the target gRPC server
            ManagedChannel channel = ManagedChannelBuilder.forAddress(applicationProperties.getToolHost(), applicationProperties.getToolPort())
                .usePlaintext()
                .idleTimeout(5, TimeUnit.SECONDS)
                .build();

            // Create a stub using the generated code and the channel
            DataServiceGrpc.DataServiceBlockingStub stub = DataServiceGrpc.newBlockingStub(channel);

            // Invoke the remote method on the target server
            FrechetResponse response = stub.frechet(request);

            // Convert the response to JSON string
            String json = response.getResult();

            // Create an ObjectMapper
            ObjectMapper objectMapper = new ObjectMapper();

            JsonNode responseObject = null;

            responseObject = objectMapper.readTree(json);
            JsonNode starts = responseObject.get("start_date");
            JsonNode ends = responseObject.get("end_date");
            for (Integer i = 0; i < starts.size(); i++) {
                String ii = i.toString();
                detectedPatterns.add(new Changepoint(i, new TimeRange(DateTimeUtil.parseDateTimeString(starts.get(ii).asText(), formatter, ZoneId.of("UTC")),
                    DateTimeUtil.parseDateTimeString(ends.get(ii).asText(), formatter, ZoneId.of("UTC"))), 0));
            }
            channel.shutdown();
            //
        } catch (Exception e) {
            e.printStackTrace();
        }
        return detectedPatterns;
    }

}
